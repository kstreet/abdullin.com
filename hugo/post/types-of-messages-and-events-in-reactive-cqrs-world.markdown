---
aliases:
- /journal/2010/9/19/types-of-messages-and-events-in-reactive-cqrs-world.html/index.html
date: 2010-09-19
title: Types of Messages and Events in Reactive CQRS World
tags:
- cqrs
- design
- event-driven
---
<p>In the previous article I've started pondering about CQRS from the perspective of Reactive Extensions and almost-infinitely scalable systems. Let's continue by formalizing types of messages and events available in this environment.</p>

<p>These building blocks are affected by the Reactive world, Domain Driven Design with Event Sourcing and Partitioning for the scalability.</p>

<p>NB: dear reader, if you are reading this article far in the future (i.e.: after September, 2010), keep in mind that views expressed here might already be outdated. In this case <a href="/tags/cqrs/">CQRS section</a> will have something more late and solid to point you towards.</p>

<p><strong>Command Message</strong> (D for Do) has following features:</p>

<ul>
<li>It is a message that instructs specific entity (identified by it's identity) to perform certain actions. </li>
<li>Messaging infrastructure is aware of this command's identity and uses it to route command to the specific partition.</li>
<li>Command message is an entity itself - it has an identity. This allows the recipient to stay idempotent and filter out seemingly similar commands that were duplicated by the messaging infrastructure.</li>
<li>This message contains contains one or more entity commands. All entity commands in the same message are directed to the entity. They are expected to fail or succeed together (essentially this is just a construct to avoid generating composite commands).</li>
<li>Entity commands are named like DoSomething, they instruct the target entity to do something that might result in different outcomes or fail.</li>
<li>In the DDD world command message determines unit of work, while specific entity commands map to the methods called upon the target aggregate root.</li>
</ul>

<p>Essentially command signature could be represented as:</p>

<pre><code>public interface IEntityCommand {}

public sealed class CommandMessage
{
  public readonly Guid EntityId;
  public readonly IDomainCommand[] Commands;
  public readonly long Version;

  // constructor
}
</code></pre>

<p>where IEntityCommand could be:</p>

<pre><code>public sealed class RenameProject : IEntityCommand
{
  public readonly string Name;

  // constructor
}
</code></pre>

<p><strong>Time</strong> tick is merely an event produced by the scheduling infrastructure within the partition. It does not have an identity, but is used to trigger processes, track timeouts and fuel temporal queries (i.e.: buffer, throttle, sample etc).</p>

<p><strong>Event</strong> is described by:</p>

<ul>
<li>Event is something that happened in the past. It is the history that can't be changed. This intent is expressed in its naming: SomethingChanged.</li>
<li>Event is associated with the sender's identity and it's version. These two properties together uniquely identify each event and allow subscriber to handle duplicates possibly generated by the scalable infrastructure.</li>
<li>Event does not have a recipient. It is merely published to the messaging infrastructure. The latter will be responsible for routing the event to it's subscribers (there could be zero or more). It will do so using event's identity and type (first allows routing event to a specific partition, second filters out only the events that the subscriber is interested in).</li>
</ul>

<p><strong>Failure</strong> is the generic unexpected exception that is the result of an attempt to process command. It indicates that something could not happen in the past and is equivalent of Reactive OnNext(Exception) translated to the domain environment. Just like in the case of observations, failure is the last item in the sequence (it terminates the reality).</p>

<ul>
<li>Failure includes information about the exception and the command(s) that caused it.</li>
<li>Since failure includes command information, it logically includes entity identifier and unique message identifier.</li>
<li>One command could logically fail one or more times (i.e. when message bus tries to handle transient error). This means that in order to uniquely identify a failure (and ensure idempotent operation, where it is needed), each failure should have it's own identity. </li>
<li>Failure</li>
</ul>
